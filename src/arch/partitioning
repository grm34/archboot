#!/bin/bash

#                         PARTITIONING SCHEME
# ============================================================================
#
# DEFAULT PARTITIONING:
#   In this mode a dedicated drive is required. We format it and create the
#   right partition table according to firmware. Then we ask for partitions
#   sizes to properly sort, create and format them.
#
# CUSTOM PARTITIONING:
#   In this mode we just ask for partitions drive ID. Partitions could
#   be on differents drives but requires you to properly create and
#   format them before running archboot.
#
#   < UEFI boot requires EFI partition type (ef00) with FAT32 filesystem >
#
# PARTITIONING SCHEME:
#
#   ROOT_PARTITION........: /mnt            (required)
#   BOOT_PARTITION........: /mnt/boot       (required)
#   SWAP_PARTITION........: no mountpoint   (optional)
#   HOME_PARTITION........: /mnt/home       (optional)
#
# We use <partprobe> to inform changes to system and to check if drive
# exists. We also add a <sleep 1> to prevent unreconized system changes.
# Logical Volume Manager (LVM) with encryption (LUKS) are supported.
# Last function is used to convert sizes to bytes for disk space check.
#
# All steps are described in the official documentation:
#
#   https://wiki.archlinux.org/index.php/Partitioning
#   https://wiki.archlinux.org/index.php/LVM
#   https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system
# ============================================================================

_default_partitioning_scheme() {

    ### Select drive to use
    _info "${MSG_LIST_DRIVES}"
    lsblk | grep "NAME\|disk" | sed "s/MOUNTPOINT//g"
    _prompt "${MSG_PROMPT_DRIVE}" "${MSG_DRIVE_EXAMPLE}"
    read -r DRIVE

    ### Check if valid drive
    CHECK=$( partprobe -d -s "/dev/${DRIVE}" )

    ### Otherwise ask again
    until [[ ${CHECK} ]]; do
        _info "${MSG_LIST_DRIVES}"
        lsblk | grep "NAME\|disk" | sed "s/MOUNTPOINT//g"
        _prompt "${MSG_PROMPT_VALID_DRIVE}" "${MSG_DRIVE_EXAMPLE}"
        read -r DRIVE
        CHECK=$( partprobe -d -s "/dev/${DRIVE}" )
    done

    ### Check if drive is mounted
    if mount | grep "${DRIVE}"; then
        _error "${DRIVE} ${MSG_IS_MOUNTED}"
    fi

    ### Return selected drive
    export DRIVE="/dev/${DRIVE}"

    ### Prepare the drive
    _info "${MSG_ARCH_DRIVE} ${DRIVE}"
    lsblk "${DRIVE}"
    _note "${MSG_WARN_LOST_DATA}"
    _confirm "${MSG_CONFIRM_FORMAT_DRIVE} ${DRIVE}?"

    case ${CONFIRM} in
        y|Y|yes|Yes|YES)

            # Format the drive
            _check wipefs --force --all "${DRIVE}"
            _check dd if=/dev/zero of="${DRIVE}" bs=512 count=1 \
conv=notrunc status=progress

            # Create GPT partition table
            printf "g\nw" | fdisk --wipe=auto "${DRIVE}"
            partprobe "${DRIVE}"; sleep 1;;
        *)
            _error "${MSG_ARCH_ABORTED}"
    esac

    ### Logical Volume Manager
    if [[ ${FIRMWARE} == "UEFI" ]]; then
        _confirm "${MSG_CONFIRM_LVM}"
        case ${CONFIRM} in
            y|Y|yes|Yes|YES) export SET_LVM="True"
        esac
    fi

    ### LUKS encrytion
    _confirm "${MSG_CONFIRM_LUKS}"
    case ${CONFIRM} in y|Y|yes|Yes|YES) export SET_LUKS="True"; esac

    ### Get optional partitions and set partitions list
    _get_user_partitions

    ### Create list to store partitions sizes
    PART_SIZES=(BOOT_SIZE ROOT_SIZE)
    SIZES=("512M" "25G")

    if [[ ${PARTITION[*]} =~ "SWAP_PARTITION" ]]; then
        PART_SIZES+=(SWAP_SIZE)
        SIZES+=("2G")
    fi

    if [[ ${PARTITION[*]} =~ "HOME_PARTITION" ]]; then
        PART_SIZES+=(HOME_SIZE)
        SIZES+=("100G")
    fi
    INDEX=0

    ### Get partitions sizes
    for PART in "${PART_SIZES[@]}"; do
        PART_NAME=${PART//_SIZE/}

        ## Free space for home
        if [[ ${PART} == "HOME_SIZE" ]]; then
            _confirm "${MSG_CONFIRM_FREESPACE} ${PART_NAME,,}?"
            case ${CONFIRM} in
                y|Y|yes|Yes|YES) PARTITION_SIZE="freespace"
            esac
        fi

        ## Otherwise ask partitions sizes
        if [[ ${PARTITION_SIZE} != "freespace" ]]; then
            _note "${MSG_PART_SIZE} {M,G,T} (e.g., ${SIZES[${INDEX}]})"
            _prompt "${MSG_PROMPT_PART_SIZE} ${PART_NAME,,}:"
            read -r PARTITION_SIZE

            # Check if valid size (otherwise ask again)
            until [[ ${PARTITION_SIZE} =~ \
^[1-9]{1}[[0-9]{0,2}(M|G|T){1}$ ]]; do
                _note "${MSG_PART_SIZE} {M,G,T} (e.g., ${SIZES[${INDEX}]})"
                _prompt "${MSG_PROMPT_VALID_PART_SIZE} ${PART_NAME,,}:"
                read -r PARTITION_SIZE
            done
        fi

        ## Return partitions sizes
        export "${PART}=${PARTITION_SIZE}"
        INDEX=${INDEX}+1
    done

    ### Create list to assign partitions sizes
    SIZES=("${BOOT_SIZE}" "${ROOT_SIZE}")

    if [[ ${PARTITION[*]} =~ "SWAP_PARTITION" ]]; then
        SIZES+=("${SWAP_SIZE}")
    fi

    if [[ ${PARTITION[*]} =~ "HOME_PARTITION" ]]; then
        SIZES+=("${HOME_SIZE}")
    fi

    ### Check disk space
    CHECK_SIZE=0
    DISK_SPACE=$( lsblk -b --output SIZE -n -d "${DRIVE}" )

    for SIZE in "${SIZES[@]}"; do
        if [[ ${SIZE} != "free space" ]]; then
            _dehumanise "${SIZE}"
            CHECK_SIZE=$(( CHECK_SIZE + BYTES ))
        fi
    done

    if (( CHECK_SIZE > DISK_SPACE )); then
        _error "${MSG_ERROR_DISK_SPACE}"
    fi

    ### Set partition order
    if [[ ${DRIVE} =~ "/dev/nvme0n" ]]; then
        ORDER=(p1 p2 p3 p4)
    else
        ORDER=(1 2 3 4)
    fi

    ### Get root UUID
    ROOT_UUID=$( blkid -o value -s UUID "${DRIVE}${ORDER[1]}" )
    export ROOT_UUID

    ### Create and format partitions
    INDEX=0

    for PART in "${PARTITION[@]}"; do
        PART_NAME=${PART//_PARTITION/}

        ## Create partitions
        _info "${MSG_CREATE_PART} ${PART_NAME,,} ${SIZES[${INDEX}]}"

        if [[ ${SET_LVM} || (${PART} == "HOME_PARTITION" && \
${HOME_SIZE} == "freespace") ]]; then
            printf "n\n\n\n\nw" | fdisk "${DRIVE}"
        elif [[ ! ${SET_LVM} ]]; then
            printf "n\n\n\n+%s\nw" "${SIZES[${INDEX}]}" | fdisk "${DRIVE}"
        fi

        ## Set partition types ()
        if [[ ${PART} == "BOOT_PARTITION" && ${FIRMWARE} == "UEFI" ]]; then
            _info "${MSG_PART_TYPE} ${FIRMWARE/U/} ${DRIVE}${ORDER[${INDEX}]}"
            printf "t\n1\nef00\nw" | gdisk "${DRIVE}"
        elif [[ ${PART} == "BOOT_PARTITION" && ${FIRMWARE} == "BIOS" ]]; then
            _info "${MSG_PART_TYPE} ${PART_NAME,,} ${DRIVE}${ORDER[${INDEX}]}"
            printf "t\n1\n4\nw" | fdisk "${DRIVE}"
        elif [[ ${SET_LVM} && ${PART} != "BOOT_PARTITION" ]]; then
            _info "${MSG_PART_TYPE} ${PART_NAME,,} ${DRIVE}${ORDER[${INDEX}]}"
            printf "t\n%s\n8e00\nw" ${INDEX} | gdisk "${DRIVE}"

        fi

        ## Set Logical Volume Manager
        if [[ ${SET_LVM} ]]; then

            # Set LVM on LUKS
            if [[ ${SET_LUKS} && ${PART} == "ROOT_PARTITION" ]]; then
                _setup_luks
                _check pvcreate /dev/mapper/cryptlvm
                _check vgcreate vg /dev/mapper/cryptlvm

            # Set LVM without encryption
            elif [[ ! ${SET_LUKS} && ${PART} == "ROOT_PARTITION" ]]; then
                _info "${MSG_SET_LVM} ${DRIVE}${ORDER[${INDEX}]}"
                _check pvcreate "${DRIVE}${ORDER[${INDEX}]}"
                _check vgcreate vg "${DRIVE}${ORDER[${INDEX}]}"
            fi

            # Create logical partitions
            _info "${MSG_CREATE_LVM} ${PART_NAME,,} ${SIZES[${INDEX}]}"

            if [[ ${PART} == "HOME_PARTITION" && \
${HOME_SIZE} == "freespace" ]]; then
                _check lvcreate -l 100%FREE vg -n "${PART_NAME,,}"
            else
                _check lvcreate -L "${SIZES[${INDEX}]}" vg -n "${PART_NAME,,}"
            fi
        fi

        # Set LUKS on partition
        if [[ (${SET_LUKS} && ${PART} != "BOOT_PARTITION") && \
! ${SET_LVM} ]]; then _setup_luks; fi

        ## Set partitions drive ID
        if [[ ${PART} != "BOOT_PARTITION" && \
(${SET_LVM} || ${SET_LUKS}) ]]; then
            DRIVE_ID="/dev/mapper/crypt${PART_NAME,,}"
        else
            DRIVE_ID="${DRIVE}${ORDER[${INDEX}]}"
        fi

        ## Inform changes to system
        partprobe "${DRIVE}"; sleep 1

        ## Format partitions
        _info "${MSG_FORMAT_PARTITION} ${PART_NAME,,} ${SIZES[${INDEX}]}"

        if [[ ${PART} == "BOOT_PARTITION" ]]; then
            yes | _check mkfs."${BOOT_FILESYSTEM}" "${DRIVE_ID}"
        elif [[ ${PART} == "SWAP_PARTITION" ]]; then
            yes | _check mkswap "${DRIVE_ID}"
        else
            yes | _check mkfs.ext4 "${DRIVE_ID}"
        fi

        ## Return partitions drive ID
        if [[ ${PART} != "BOOT_PARTITION" && \
(${SET_LVM} || ${SET_LUKS}) ]]; then
            export "${PART}=${DRIVE_ID}"
        else
            export "${PART}=${DRIVE}${ORDER[${INDEX}]}"
        fi

        ## Increase index
        INDEX=${INDEX}+1
    done
}

_custom_partitioning_scheme() {

    ### Get optional partitions and set partitions list
    _get_user_partitions

    ### Get partitions drive ID
    _info "${MSG_LIST_DRIVES}"

    for PART in "${PARTITION[@]}"; do
        lsblk | grep "NAME\|disk\|part"
        PART_NAME=${PART//_PARTITION/}

        # Get drive ID
        _prompt "${MSG_PROMPT_ID} ${PART_NAME,,}:" "${MSG_ID_EXAMPLE}"
        read -r DRIVE_ID

        # Check if valid partition
        CHECK=$( partprobe -d -s "/dev/${DRIVE_ID}" )

        # Otherwise ask again
        until [[ ${CHECK} ]]; do
            _info "${MSG_LIST_DRIVES}"
            lsblk | grep "NAME\|disk\|part"
           _prompt "${MSG_PROMPT_VALIDID} ${PART_NAME,,}:" "${MSG_ID_EXAMPLE}"
            read -r DRIVE_ID
            CHECK=$( partprobe -d -s "/dev/${DRIVE_ID}" )
        done

        # Return partitions drive ID
        export "${PART}=/dev/${DRIVE_ID}"
    done

    ### Set and return boot drive
    if [[ ${BOOT_PARTITION} =~ "/dev/nvme0n" ]]; then
        export DRIVE=${BOOT_PARTITION%p*}
    else
        export DRIVE=${BOOT_PARTITION//[0-9]}
    fi
}

_get_user_partitions() {

    ### Set required and optional partitions
    PARTITION=(BOOT_PARTITION ROOT_PARTITION)
    OPTIONAL=(SWAP_PARTITION HOME_PARTITION)

    ### Get optional partitions
    for PART in "${OPTIONAL[@]}"; do
        PART_NAME=${PART//_PARTITION/}
        _confirm "${MSG_CONFIRM_OPT_PART} ${PART_NAME,,}?"

        case ${CONFIRM} in
            y|Y|yes|Yes|YES) PARTITION+=("${PART}")
        esac
    done

    ### Return partitions list
    export PARTITION
}

_setup_luks() {
    if [[ ${LVM} ]]; then PART_NAME="lvm"; fi
    _info "${MSG_SET_LUKS} ${PART_NAME,,} ${DRIVE}${ORDER[${INDEX}]}"

    # Encrypt partition
    if [[ ${FIRMWARE} == "UEFI" ]]; then
        yes | _check cryptsetup -v luksFormat "${DRIVE}${ORDER[${INDEX}]}"
    else
        yes | \
_check cryptsetup -v luksFormat --type luks1 "${DRIVE}${ORDER[${INDEX}]}"
    fi

    # Open partition mapper
    yes | _check cryptsetup -v luksOpen \
"${DRIVE}${ORDER[${INDEX}]}" "crypt${PART_NAME,,}"
}

_dehumanise() {

    ### Convert human readable to bytes
    BYTES=$( echo "${1}" | awk \
        'BEGIN{IGNORECASE = 1}
        function printpower(n,b,p) {printf "%u\n", n*b^p; next}
        /[0-9]$/{print $1;next};
        /M/{printpower($1, 2, 20)};
        /G/{printpower($1, 2, 30)};
        /T/{printpower($1, 2, 40)}'
    )
}

# archboot - Arch Linux Installer by grm34 under Apache License 2.0
# ============================================================================
